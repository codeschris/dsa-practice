#My implementation of the Binary search algorithm (lacks the concept of midpoint)
def binary_search(input_array, element):
    for i in range(len(input_array)):
        if input_array[i] < element:
            input_array[i] = input_array[(i + 1)]
        elif input_array[i] == element:
            return i + 1
        else:
            return -1

"""Better solutions that start from midpoint of the array"""
#Recursive option
def binary_search1(arr, low, high, x):
    if high >= low:
        mid = (high + low) // 2

        if arr[mid] == x:   #if element is present at midpoint itself
            return mid
        elif arr[mid] > x:
            return binary_search1(arr, low, mid - 1, x) #if present in left subarray
        else:
            return binary_search1(arr, mid + 1, high, x)  #if present in right subarray
    else:
        return -1
    
#iterative option
def binary_search2(arr, x):
    low = 0
    high = len(arr) - 1
    mid = 0

    while low <= high:
        mid = (high + low) // 2
        if arr[mid] < x:
            low = mid + 1
        elif arr[mid] > x:
            high = mid - 1
        else:
            return mid
    return -1

"""Quick-sort"""
#My implementation
def quick_sort(array):
    pass

#Solution 1(generated by Chat-GPT for reference)
def quicksort(array):
    if len(array) <= 1:
        return array
        
    pivot = array[len(array) // 2]
    left = [x for x in array if x < pivot]
    middle = [x for x in array if x == pivot]
    right = [x for x in array if x > pivot]
    
    return quicksort(left) + middle + quicksort(right)


#test-cases
arr = [ 2, 3, 4, 10, 40 ]
x = 10

result = binary_search2(arr, x)
result2 = binary_search1(arr, 0, len(arr)-1, x)
 
if result != -1:
    print("Element is present at index", str(result))
else:
    print("Element is not present in array")

#Quicksort
test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]
print(quicksort(test))